# Workloads information - localhost
# Ref: https://etcd.io/docs/current/op-guide/configuration/ + https://github.com/bitnami/charts/tree/master/bitnami/etcd + https://etcd.io/docs/v3.4.0/op-guide/container/ and comments at end!
# Example of escaping to the value to be parsed inside container: ``$``(MY_POD_IP``)
# Notes: Using internal Docker addresses since etcd refuses the client or peer URLs when trying to bind to the host name or IP
# Ingress: TCP: --set tcp.[external-port]="[namespace]/[service]:[port]"
---
globalVariables:
  # TO-SET: set domain below, like yrn42.com
  # websiteDomain:         "yrn42website-domain"
  websiteDomain:         "yrn42.com"
  # TO-SET: set site address below, like www.yrn42.com
  # websiteHost:           "www.yrn42website-domain"
  # see: https://letsencrypt.org/docs/certificates-for-localhost/
  websiteHost:           "localhost"
  websiteTlsSecret:      "website-tls-secret"
  certManagerIssuerEmail: "certificates@cloudtalk.app"
  _registryLocation:     "$($([Environment]::GetEnvironmentVariable(\"${env:registryName}.registryLocation\")) -replace '.azurecr.io','')"
  dockerServer:          "http://${env:_registryLocation}"
  dockerUsername:        "placeholder"
  dockerPassword:        "placeholder"
  ingressClass:          "nginx"
  _namespace001:         "${env:project}-${env:runId}-001"
  _namespace002:         "${env:project}-${env:runId}-002"
  _namespace003:         "${env:project}-${env:runId}-003"
  _frontend001:          "${env:project}001.${env:_namespace001}"
  _frontend002:          "${env:project}002.${env:_namespace002}"
  _frontend003:          "${env:project}003.${env:_namespace003}"
  # Use any of the frontendIps for the patching in the localhost
  _frontendIp:           "$([Environment]::GetEnvironmentVariable(\"${env:runTag}-${env:_namespace001}.frontendIp\"))"
  etcdPassword:          "yurunaDemo"
  etcdPrefix:            "etcd"
  etcdAddress001:        '${env:etcdPrefix}001-0.${env:etcdPrefix}001-headless.${env:_namespace001}.svc.cluster.local'
  etcdPortClient001:     "1379"
  etcdPortPeer001:       "1380"
  etcdAddress002:        '${env:etcdPrefix}002-0.${env:etcdPrefix}002-headless.${env:_namespace002}.svc.cluster.local'
  etcdPortClient002:     "2379"
  etcdPortPeer002:       "2380"
  etcdAddress003:        '${env:etcdPrefix}003-0.${env:etcdPrefix}003-headless.${env:_namespace003}.svc.cluster.local'
  etcdPortClient003:     "3379"
  etcdPortPeer003:       "3380"
  # https://helm.sh/docs/intro/using_helm/#the-format-and-limitations-of---set
  etcdCluster:           ${env:etcdPrefix}001=http://${env:etcdAddress001}:${env:etcdPortPeer001}\,${env:etcdPrefix}002=http://${env:etcdAddress002}:${env:etcdPortPeer002}\,${env:etcdPrefix}003=http://${env:etcdAddress003}:${env:etcdPortPeer003}
  etcdClusterToken:      "nossila"
  waitTimeout:           "2m"

workloads:

  # Cleanup and ingress
  - context: "docker-desktop"
    variables:
      namespace: "default"
    deployments:
      # Always delete everything first, so that no references are created to existing resources previously available
      - kubectl: "delete namespace ingress-basic --ignore-not-found=true --v=1"
      - kubectl: "delete namespace ${env:_namespace001} --ignore-not-found=true --v=1"
      - kubectl: "delete namespace ${env:_namespace002} --ignore-not-found=true --v=1"
      - kubectl: "delete namespace ${env:_namespace003} --ignore-not-found=true --v=1"
      - kubectl: "config set-context --current --namespace=${env:namespace} --v=1"
      - kubectl: "delete secret registry-credential --ignore-not-found=true"
      - kubectl: "create secret docker-registry registry-credential --docker-server=http://${env:_registryLocation} --docker-username=${env:dockerUsername} --docker-password=${env:dockerPassword}"
      - shell: 'Write-Information "   Waiting: kubectl wait --for=condition=Ready pods --all --all-namespaces --timeout=${env:waitTimeout}"'
      - kubectl: "wait --for=condition=Ready pods --all --all-namespaces --timeout=${env:waitTimeout}"
          
  - context: "${env:runTag}-${env:project}-${env:runId}-001"
    variables:
      _number: "001"
      _basename: "${env:containerPrefix}${env:_number}"
      namespace: '$([Environment]::GetEnvironmentVariable("_namespace${env:_number}"))'
      frontendApp: "${env:_basename}-site"
      frontendPathBase: "front${env:_number}"
      backendApp: "${env:_basename}-grava"
      backendPathBase: "back${env:_number}"
      replicatedStateApp: "${env:etcdPrefix}${env:_number}"
      replicatedStatePortClient: '$([Environment]::GetEnvironmentVariable("etcdPortClient${env:_number}"))'
      replicatedStatePortPeer: '$([Environment]::GetEnvironmentVariable("etcdPortPeer${env:_number}"))'
      replicatedStateAppAddress: '$([Environment]::GetEnvironmentVariable("etcdAddress${env:_number}"))'
      _endpointHost: '$([Environment]::GetEnvironmentVariable("${env:contextName}.hostname"))'
    deployments:
      - kubectl: "create namespace ${env:namespace} --v=1"
      - kubectl: "config set-context --current --namespace=${env:namespace} --v=1"
      - kubectl: "create secret docker-registry registry-credential --docker-server=http://${env:_registryLocation} --docker-username=${env:dockerUsername} --docker-password=${env:dockerPassword}"
      - chart: "replicator-app"
        variables:
          installName: "${env:_basename}-deployment"
      - helm: "repo add bitnami https://charts.bitnami.com/bitnami"
      - helm: "repo update"
      - helm: >
          install ${env:replicatedStateApp} bitnami/etcd
          --namespace ${env:namespace}
          --set persistence.enabled=false
          --set auth.rbac.enabled=false
          --set containerPorts.client=${env:replicatedStatePortClient}
          --set containerPorts.peer=${env:replicatedStatePortPeer}
          --set service.port=${env:replicatedStatePortClient}
          --set service.peerPort=${env:replicatedStatePortPeer}
          --set service.type=LoadBalancer
          --set extraEnvVars[0].name=ALLOW_NONE_AUTHENTICATION
          --set extraEnvVars[0].value=yes
          --set extraEnvVars[1].name=ETCD_NAME
          --set extraEnvVars[1].value=${env:replicatedStateApp}
          --set extraEnvVars[2].name=ETCD_ADVERTISE_CLIENT_URLS
          --set extraEnvVars[2].value=http://${env:replicatedStateAppAddress}:${env:replicatedStatePortClient}
          --set extraEnvVars[3].name=ETCD_LISTEN_CLIENT_URLS
          --set extraEnvVars[3].value=http://0.0.0.0:${env:replicatedStatePortClient}
          --set extraEnvVars[4].name=ETCD_INITIAL_ADVERTISE_PEER_URLS
          --set extraEnvVars[4].value=http://${env:replicatedStateAppAddress}:${env:replicatedStatePortPeer}
          --set extraEnvVars[5].name=ETCD_LISTEN_PEER_URLS
          --set extraEnvVars[5].value=http://0.0.0.0:${env:replicatedStatePortPeer}
          --set extraEnvVars[6].name=ETCD_INITIAL_CLUSTER
          --set extraEnvVars[6].value=${env:etcdCluster}
          --set extraEnvVars[7].name=ETCD_INITIAL_CLUSTER_STATE
          --set extraEnvVars[7].value=new
          --set extraEnvVars[8].name=ETCD_INITIAL_CLUSTER_TOKEN
          --set extraEnvVars[8].value=${env:etcdClusterToken}
          --debug
      - kubectl: "expose deployment/${env:frontendApp}"
      - kubectl: "expose deployment/${env:backendApp}"
      - shell: 'Write-Information "   Enpoint: http://${env:_frontendIp}/${env:frontendPathBase}"'

  - context: "${env:runTag}-${env:project}-${env:runId}-002"
    variables:
      _number: "002"
      _basename: "${env:containerPrefix}${env:_number}"
      namespace: '$([Environment]::GetEnvironmentVariable("_namespace${env:_number}"))'
      frontendApp: "${env:_basename}-site"
      frontendPathBase: "front${env:_number}"
      backendApp: "${env:_basename}-grava"
      backendPathBase: "back${env:_number}"
      replicatedStateApp: "${env:etcdPrefix}${env:_number}"
      replicatedStatePortClient: '$([Environment]::GetEnvironmentVariable("etcdPortClient${env:_number}"))'
      replicatedStatePortPeer: '$([Environment]::GetEnvironmentVariable("etcdPortPeer${env:_number}"))'
      replicatedStateAppAddress: '$([Environment]::GetEnvironmentVariable("etcdAddress${env:_number}"))'
      _endpointHost: '$([Environment]::GetEnvironmentVariable("${env:contextName}.hostname"))'
    deployments:
      - kubectl: "create namespace ${env:namespace} --v=1"
      - kubectl: "config set-context --current --namespace=${env:namespace} --v=1"
      - kubectl: "create secret docker-registry registry-credential --docker-server=http://${env:_registryLocation} --docker-username=${env:dockerUsername} --docker-password=${env:dockerPassword}"
      - chart: "replicator-app"
        variables:
          installName: "${env:_basename}-deployment"
      - helm: "repo add bitnami https://charts.bitnami.com/bitnami"
      - helm: "repo update"
      - helm: >
          install ${env:replicatedStateApp} bitnami/etcd
          --namespace ${env:namespace}
          --set persistence.enabled=false
          --set auth.rbac.enabled=false
          --set containerPorts.client=${env:replicatedStatePortClient}
          --set containerPorts.peer=${env:replicatedStatePortPeer}
          --set service.port=${env:replicatedStatePortClient}
          --set service.peerPort=${env:replicatedStatePortPeer}
          --set service.type=LoadBalancer
          --set extraEnvVars[0].name=ALLOW_NONE_AUTHENTICATION
          --set extraEnvVars[0].value=yes
          --set extraEnvVars[1].name=ETCD_NAME
          --set extraEnvVars[1].value=${env:replicatedStateApp}
          --set extraEnvVars[2].name=ETCD_ADVERTISE_CLIENT_URLS
          --set extraEnvVars[2].value=http://${env:replicatedStateAppAddress}:${env:replicatedStatePortClient}
          --set extraEnvVars[3].name=ETCD_LISTEN_CLIENT_URLS
          --set extraEnvVars[3].value=http://0.0.0.0:${env:replicatedStatePortClient}
          --set extraEnvVars[4].name=ETCD_INITIAL_ADVERTISE_PEER_URLS
          --set extraEnvVars[4].value=http://${env:replicatedStateAppAddress}:${env:replicatedStatePortPeer}
          --set extraEnvVars[5].name=ETCD_LISTEN_PEER_URLS
          --set extraEnvVars[5].value=http://0.0.0.0:${env:replicatedStatePortPeer}
          --set extraEnvVars[6].name=ETCD_INITIAL_CLUSTER
          --set extraEnvVars[6].value=${env:etcdCluster}
          --set extraEnvVars[7].name=ETCD_INITIAL_CLUSTER_STATE
          --set extraEnvVars[7].value=new
          --set extraEnvVars[8].name=ETCD_INITIAL_CLUSTER_TOKEN
          --set extraEnvVars[8].value=${env:etcdClusterToken}
          --debug
      - kubectl: "expose deployment/${env:frontendApp}"
      - kubectl: "expose deployment/${env:backendApp}"
      - shell: 'Write-Information "   Enpoint: http://${env:_frontendIp}/${env:frontendPathBase}"'

  - context: "${env:runTag}-${env:project}-${env:runId}-003"
    variables:
      _number: "003"
      _basename: "${env:containerPrefix}${env:_number}"
      namespace: '$([Environment]::GetEnvironmentVariable("_namespace${env:_number}"))'
      frontendApp: "${env:_basename}-site"
      frontendPathBase: "front${env:_number}"
      backendApp: "${env:_basename}-grava"
      backendPathBase: "back${env:_number}"
      replicatedStateApp: "${env:etcdPrefix}${env:_number}"
      replicatedStatePortClient: '$([Environment]::GetEnvironmentVariable("etcdPortClient${env:_number}"))'
      replicatedStatePortPeer: '$([Environment]::GetEnvironmentVariable("etcdPortPeer${env:_number}"))'
      replicatedStateAppAddress: '$([Environment]::GetEnvironmentVariable("etcdAddress${env:_number}"))'
      _endpointHost: '$([Environment]::GetEnvironmentVariable("${env:contextName}.hostname"))'
    deployments:
      - kubectl: "create namespace ${env:namespace} --v=1"
      - kubectl: "config set-context --current --namespace=${env:namespace} --v=1"
      - kubectl: "create secret docker-registry registry-credential --docker-server=http://${env:_registryLocation} --docker-username=${env:dockerUsername} --docker-password=${env:dockerPassword}"
      - chart: "replicator-app"
        variables:
          installName: "${env:_basename}-deployment"
      - helm: "repo add bitnami https://charts.bitnami.com/bitnami"
      - helm: "repo update"
      - helm: >
          install ${env:replicatedStateApp} bitnami/etcd
          --namespace ${env:namespace}
          --set persistence.enabled=false
          --set auth.rbac.enabled=false
          --set containerPorts.client=${env:replicatedStatePortClient}
          --set containerPorts.peer=${env:replicatedStatePortPeer}
          --set service.port=${env:replicatedStatePortClient}
          --set service.peerPort=${env:replicatedStatePortPeer}
          --set service.type=LoadBalancer
          --set extraEnvVars[0].name=ALLOW_NONE_AUTHENTICATION
          --set extraEnvVars[0].value=yes
          --set extraEnvVars[1].name=ETCD_NAME
          --set extraEnvVars[1].value=${env:replicatedStateApp}
          --set extraEnvVars[2].name=ETCD_ADVERTISE_CLIENT_URLS
          --set extraEnvVars[2].value=http://${env:replicatedStateAppAddress}:${env:replicatedStatePortClient}
          --set extraEnvVars[3].name=ETCD_LISTEN_CLIENT_URLS
          --set extraEnvVars[3].value=http://0.0.0.0:${env:replicatedStatePortClient}
          --set extraEnvVars[4].name=ETCD_INITIAL_ADVERTISE_PEER_URLS
          --set extraEnvVars[4].value=http://${env:replicatedStateAppAddress}:${env:replicatedStatePortPeer}
          --set extraEnvVars[5].name=ETCD_LISTEN_PEER_URLS
          --set extraEnvVars[5].value=http://0.0.0.0:${env:replicatedStatePortPeer}
          --set extraEnvVars[6].name=ETCD_INITIAL_CLUSTER
          --set extraEnvVars[6].value=${env:etcdCluster}
          --set extraEnvVars[7].name=ETCD_INITIAL_CLUSTER_STATE
          --set extraEnvVars[7].value=new
          --set extraEnvVars[8].name=ETCD_INITIAL_CLUSTER_TOKEN
          --set extraEnvVars[8].value=${env:etcdClusterToken}
          --debug
      - kubectl: "expose deployment/${env:frontendApp}"
      - kubectl: "expose deployment/${env:backendApp}"
      - shell: 'Write-Information "   Enpoint: http://${env:_frontendIp}/${env:frontendPathBase}"'

  - context: "docker-desktop"
    variables:
      namespace: "default"
      _gravapod001: '$(kubectl get pods --selector=app=${env:containerPrefix}001-grava --all-namespaces --no-headers -o custom-columns=":metadata.name")'
      _gravapod002: '$(kubectl get pods --selector=app=${env:containerPrefix}002-grava --all-namespaces --no-headers -o custom-columns=":metadata.name")'
      _gravapod003: '$(kubectl get pods --selector=app=${env:containerPrefix}003-grava --all-namespaces --no-headers -o custom-columns=":metadata.name")'
    deployments:
      - kubectl: "config set-context --current --namespace=${env:namespace} --v=1"
      # Ingress
      - kubectl: "create namespace ingress-basic --v=1"
      - helm: "repo add ingress-nginx https://kubernetes.github.io/ingress-nginx"
      - helm: "repo update"
      - helm: >
          install nginx-ingress ingress-nginx/ingress-nginx
          --namespace ingress-basic
          --set controller.replicaCount=2
          --set controller.nodeSelector."beta\.kubernetes\.io/os"=linux
          --set defaultBackend.nodeSelector."beta\.kubernetes\.io/os"=linux
          --set controller.service.externalTrafficPolicy="Local"
          --set controller.admissionWebhooks.enabled=false
          --set controller.ingressClass=${env:ingressClass}
          --set controller.service.loadBalancerIP="${env:_frontendIp}"
          --set tcp.${env:etcdPortClient001}="${env:_namespace001}/${env:etcdPrefix}001:${env:etcdPortClient001}"
          --set tcp.${env:etcdPortPeer001}="${env:_namespace001}/${env:etcdPrefix}001:${env:etcdPortPeer001}"
          --set tcp.${env:etcdPortClient002}="${env:_namespace002}/${env:etcdPrefix}002:${env:etcdPortClient002}"
          --set tcp.${env:etcdPortPeer002}="${env:_namespace002}/${env:etcdPrefix}002:${env:etcdPortPeer002}"
          --set tcp.${env:etcdPortClient003}="${env:_namespace003}/${env:etcdPrefix}003:${env:etcdPortClient003}"
          --set tcp.${env:etcdPortPeer003}="${env:_namespace003}/${env:etcdPrefix}003:${env:etcdPortPeer003}"
          --debug
      - kubectl: "patch svc nginx-ingress-ingress-nginx-controller -n ingress-basic -p '{\\\"spec\\\": {\\\"type\\\": \\\"LoadBalancer\\\", \\\"externalIPs\\\":[\\\"${env:_frontendIp}\\\"]}}'"
      - kubectl: "patch svc etcd001 -n ${env:_namespace001} -p '{\\\"spec\\\": {\\\"type\\\": \\\"LoadBalancer\\\", \\\"externalIPs\\\":[\\\"${env:_frontendIp}\\\"]}}'"
      - kubectl: "patch svc etcd002 -n ${env:_namespace002} -p '{\\\"spec\\\": {\\\"type\\\": \\\"LoadBalancer\\\", \\\"externalIPs\\\":[\\\"${env:_frontendIp}\\\"]}}'"
      - kubectl: "patch svc etcd003 -n ${env:_namespace003} -p '{\\\"spec\\\": {\\\"type\\\": \\\"LoadBalancer\\\", \\\"externalIPs\\\":[\\\"${env:_frontendIp}\\\"]}}'"
      - shell: 'Write-Information "-- Waiting: kubectl wait --for=condition=Ready pods --all --all-namespaces --timeout=120s"'
      - kubectl: "wait --for=condition=Ready pods --all --all-namespaces --timeout=120s"
      - shell: 'Write-Information "-- Check containers started: kubectl get pods --all-namespaces"'
      - shell: 'Write-Information "-- Check services: kubectl get svc --all-namespaces"'
